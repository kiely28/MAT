Yes üëç ‚Äî with your current code, both Tap In and Tap Out paths end with this block:

// Reset input and focus
txtCardSerial.Text = "";
ScriptManager.RegisterStartupScript(this, GetType(), "setFocus",
    $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);

So in theory, both Tap In and Tap Out should focus back to txtCardSerial after the postback.


---

Why you might see different behavior

ASP.NET‚Äôs ScriptManager.RegisterStartupScript uses a script key ("setFocus" in your case).
If the same key is reused multiple times during one request, only the last one wins.
If another script (e.g. your fadeOutAlert()) is registered after it with the same key, your focus script gets overridden.

Sometimes Bootstrap‚Äôs modal/alert animations can also steal focus back to the button you clicked.



---

‚úÖ How to make sure both Tap In and Tap Out always refocus

Change the focus script registration to use a unique key every time:

// Reset input and focus
txtCardSerial.Text = "";
ScriptManager.RegisterStartupScript(this, GetType(), Guid.NewGuid().ToString(),
    $"document.getElementById('{txtCardSerial.ClientID}').focus();", true);

This way, whether you Tap In or Tap Out, the focus script always runs.


---

üëâ Do you want me to adjust your txtCardSerial_TextChanged method so it‚Äôs guaranteed to refocus on txtCardSerial after both Tap In and Tap Out?



-- Update Panel
Good question üëç Right now, your tapping (txtCardSerial_TextChanged) does a full page postback ‚Äî meaning the entire page refreshes whenever someone taps a card.

To make it smoother, you can handle taps with ASP.NET AJAX so only the alert panel updates (no full reload).


---

‚úÖ Option 1: Use UpdatePanel (fastest for Web Forms)

Wrap the controls that need updating (textbox, alert panel) inside an UpdatePanel.

Example

<asp:ScriptManager ID="ScriptManager1" runat="server"></asp:ScriptManager>

<asp:UpdatePanel ID="updTapArea" runat="server" UpdateMode="Conditional">
    <ContentTemplate>
        <div class="mb-3">
            <asp:TextBox ID="txtCardSerial" runat="server" CssClass="form-control custom-input"
                placeholder="Place your ID card on the reader" TextMode="Password"
                AutoPostBack="true" OnTextChanged="txtCardSerial_TextChanged" />
        </div>

        <div class="mt-3">
            <asp:Panel ID="pnlAlert" runat="server" Visible="false"
                CssClass="alert alert-dismissible fade show" role="alert">
                <h5 class="alert-heading">
                    <asp:Label ID="lblAlertHeading" runat="server"></asp:Label>
                </h5>
                <p class="mb-0 fs-5">
                    <asp:Label ID="lblAlertName" runat="server"></asp:Label>
                </p>
                <p class="fs-6">
                    <asp:Label ID="lblAlertDept" runat="server"></asp:Label>
                </p>
                <p class="mb-0">
                    <asp:Label ID="lblAlertDateTime" runat="server"></asp:Label>
                </p>
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </asp:Panel>
        </div>
    </ContentTemplate>
    <Triggers>
        <!-- txtCardSerial triggers async postback -->
        <asp:AsyncPostBackTrigger ControlID="txtCardSerial" EventName="TextChanged" />
    </Triggers>
</asp:UpdatePanel>

What changes

Only the UpdatePanel content updates when a card is tapped.

The navbar, buttons, and rest of the page won‚Äôt reload.

Your existing server-side code (txtCardSerial_TextChanged) still works.



---

‚úÖ Option 2: Use jQuery AJAX ($.ajax) + WebMethod

More modern, avoids ViewState overhead.

1. Add a static WebMethod in your code-behind:

[System.Web.Services.WebMethod]
public static string ProcessTap(string cardSerial, string tapMode, string meetingId)
{
    // Same logic as txtCardSerial_TextChanged, but simplified
    // return JSON or string result

    return "You have tapped in successfully!";
}


2. Call it via AJAX in JavaScript:

function tapCard(cardSerial, tapMode, meetingId) {
    $.ajax({
        type: "POST",
        url: "meetingattendance.aspx/ProcessTap",
        data: JSON.stringify({ cardSerial: cardSerial, tapMode: tapMode, meetingId: meetingId }),
        contentType: "application/json; charset=utf-8",
        dataType: "json",
        success: function (response) {
            let message = response.d;
            $("#<%= pnlAlert.ClientID %>").show().find("h5").text(message);
            $("#<%= txtCardSerial.ClientID %>").val("").focus();
        },
        error: function (xhr, status, error) {
            alert("Error: " + error);
        }
    });
}


3. Trigger this when the textbox changes:

$("#<%= txtCardSerial.ClientID %>").on("change", function () {
    let cardSerial = $(this).val();
    let tapMode = $("input[name='tapMode']:checked").val();
    let meetingId = $("#<%= hfMeetingID.ClientID %>").val();

    tapCard(cardSerial, tapMode, meetingId);
});




---

‚öñÔ∏è Which should you use?

UpdatePanel ‚Üí easier, minimal code changes, works with your existing event handler.

AJAX + WebMethod ‚Üí cleaner, faster, more control, but requires rewriting txtCardSerial_TextChanged logic into a static method.



---

üëâ Do you want me to convert your current txtCardSerial_TextChanged logic into a WebMethod (Option 2), or keep it inside an UpdatePanel (Option 1, easiest drop-in)?

